# sylar

## 开发环境
CentOS7
gcc 9.1
cmake

## 项目目录结构
bin -- 二进制文件
build -- 中间文件路径
cmake -- cmake函数文件夹
CMakeLists.txt -- cmake的定义文件
lib -- 库的输出路径
Makefile -- 为了编码方便
sylar -- 源代码文件
tests -- 测试代码文件

## 日志系统
任何一个系统，第一步都先要设置好日志系统。因为当系统出问题后、需要统计、分析系统数据时，一个良好的日志系统，都会让这些工作事半功倍。

仿照Log4J做一套日志系统
Logger（定义日志类别：框架级的日志用唯一标识来区分，业务级日志用另外名称，为什么要这样？因为把所有日志混到一起会比较混乱，我们可以定义在正常情况下，系统可以显示L级别日志或者W级别日志；业务级别日志需要在开debug模式后才显示，而且只是开启了业务级的debug，而不是系统级的debug；每个log产生的文件是不同的，方便我们详细的定义这个log是要落地到文件里去，还是发送到网络中去，这样就统一一点）
    |   
        Formatter（日志格式）
    |
Appender（日志输出的地方，把日志输出到控制台，或者输出成文件，也可以自定义logserver，专门的日志收集器）

用到了boost库，这个库使用默认路径安装，安装在了/usr/local/include里

开发过程中存在的问题：
1.没有事先做好的规划，写好一个函数后，发现又需要新的参数（比如event和level），就又得给函数新传递参数，这样就会产生很多改动，很不方便。怎么解决？

## 配置系统
配套开发一个配置系统，可以用配置系统直接设置日志的格式，级别，输出地等等。
底层配置用yaml来做，yaml相比于xml、json来说更简单、更灵活一些
通过yaml来修改、加载配置

用到了yaml-cpp库，采用默认路径安装的方式，安装在了/usr/local/include里
yaml用法
： -- 表示是一个object，映射到map
-  -- 表示是数组

出现了动态库链接错误的问题、未定义的引用问题(s_datas)，本质原因是对库的编译-链接不清楚，得研究一下这方面

## 协程库封装
协程和异步
异步：对开发人员技术功底很高。如果出现很多层次的异步调用，会比较混乱，调试很难，开发很难。
协程：可以将异步的操作封装成同步。用一个协程库+底层kuke，kuke到socket API那一层，当API要请求异步操作的时候，把读写事件先注册起来，然后当请求读写的时候，会陷入到epoll里面去，此时把整个协程先挂起来，当数据回来的时候，再从协程把它唤起。这样写程序的人，并不需要知道协程库的存在，只需要用我们这套协程库框架，自然而然的像写同步一样，写的代码是同步的，但能实现异步的功能。

## socket函数库开发

## HTTP协议开发

## 分布式协议
在高性能服务器开发中，分布式服务器内部都有共享请求，内部共享请求走HTTP协议，性能可能会比较差一点，没有二进制方便，因此要有一个分布式协议。
把要做的逻辑业务抽象成一个个插件，以SO的形式来提供。
服务器在跑起来的时候，自然而然能实现服务器之间的交互，交互的逻辑放在插件中，这样就把业务功能和系统功能拆分开来了。业务开发归业务开发，系统优化归系统优化。

## 推荐系统
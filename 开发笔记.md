# sylar

## 开发环境
CentOS7
gcc 9.1
cmake

## 通过项目要深入学习的知识
1.cmake的使用；用cmake构建软件项目(https://juejin.cn/post/6844904097158529032)
2.git的使用；用git管理项目
 
## git
在使用git时遇到的问题：当突然发现不能push代码了，需要重新输入用户名和密码时，注意这个密码不是github的登录密码，而是个人访问令牌(git在2021年推出的)，
这个访问令牌需要自己设置，并且一般不设置为永久有效，那么当某一天令牌到期后，又会要求再次输入用户名和密码，这就是为什么git突然不能push了

遇到一个问题是，测试产生了超过100M的mutex.txt文件，这个文件太大，push失败，所以不要push这个文件，具体做法是：
回退commit，然后写一个.gitignore文件，里面写上每次git add时忽略文件里的内容，然后再次重新commit & push
学到的操作是回退commit、回退git add、add和commit的区别、编写.gitignore文件
## 项目目录结构
bin -- 二进制文件
build -- 中间文件路径
cmake -- cmake函数文件夹
CMakeLists.txt -- cmake的定义文件
lib -- 库的输出路径
Makefile -- 为了编码方便
sylar -- 源代码文件
tests -- 测试代码文件

## 日志系统
任何一个系统，第一步都先要设置好日志系统。因为当系统出问题后、需要统计、分析系统数据时，一个良好的日志系统，都会让这些工作事半功倍。

仿照Log4J做一套日志系统
Logger（定义日志类别：框架级的日志用唯一标识来区分，业务级日志用另外名称，为什么要这样？因为把所有日志混到一起会比较混乱，我们可以定义在正常情况下，系统可以显示L级别日志或者W级别日志；业务级别日志需要在开debug模式后才显示，而且只是开启了业务级的debug，而不是系统级的debug；每个log产生的文件是不同的，方便我们详细的定义这个log是要落地到文件里去，还是发送到网络中去，这样就统一一点）
    |   
        Formatter（日志格式）
    |
Appender（日志输出的地方，把日志输出到控制台，或者输出成文件，也可以自定义logserver，专门的日志收集器）

用到了boost库，这个库使用默认路径安装，安装在了/usr/local/include里

开发过程中存在的问题：
1.没有事先做好的规划，写好一个函数后，发现又需要新的参数（比如event和level），就又得给函数新传递参数，这样就会产生很多改动，很不方便。怎么解决？

## 配置系统
配套开发一个配置系统，可以用配置系统直接设置日志的格式，级别，输出地等等。
底层配置用yaml来做，yaml相比于xml、json来说更简单、更灵活一些
通过yaml来修改、加载配置

用到了yaml-cpp库，采用默认路径安装的方式，安装在了/usr/local/include里
yaml用法
： -- 表示是一个object，映射到map
-  -- 表示是数组

出现了动态库链接错误的问题、未定义的引用问题(s_datas)，本质原因是对库的编译-链接不清楚，得研究一下这方面

配置系统原则：约定优于配置
实际的配置参数有上百个，但是真正需要改动的配置参数只有十几个，采用约定优于配置，就可以减少配置量

一开始只是实现了简单的内置类型转换，用boost库实现的。但实际上不是这样的，比如实际我的配置就是个vector、map或者set，那怎么办呢？
因为我直接用字符串转成相应的vector、map不合适，那怎么办呢？
解决办法是定义一个中间的类型转换，简单的类型我可以用默认的方式就可以支持了，复杂的类型呢？也分很多种，比如vector、map这种，也算是简单类型中稍微复杂一点的
类型，这种类型呢我们就可以用一些通用的转换方式直接做了；另外一种是我们自己定义的结构体，比如struct，里面对应的每一个配置项都要解析，这种怎么办？所以我们需要
一个我们可以自定义的解析的方式。

还未实现vector转为string的功能，所以还需要做一些偏特化,如果我们不想自定义FromStr和ToStr，那么我们就要把常用容器的偏特化做一下

因为实现是通过递归来实现的，所以无论嵌套多少层，都可以成功

新增配置功能：我的配置如果发生变化了，能不能让我代码级别能感知到这个配置变化，并做出对应操作.
比如：1.原来配置里写了A路径的文件，后来改了写B路径文件，那我能不能马上感知到你改路径了，我马上形成新的日志文件.
     2.原来业务是A策略，后来修改为B策略，那怎么让我代码级别能感知到这个变更？
解决方案：当配置变更的时候，应该触发一个事件，每个人关心的事件不一样，如果某个人关心这个事件，那就捕捉这个事件，否则就不予理睬。即：
当一个配置项发生修改的时候，可以反向通知对应的代码，回调

配置系统有个问题时，当多线程情况下，有的人在修改配置，有的人在读配置，此时就会存在线程安全的问题。这个问题等后面写了线程模块后，再回来处理一下这个问题

## 日志系统整合配置系统
所有日志统一放在logs目录下
logs：
    — name： root
      level： (debug, info, warn, error, fatal)
      formatter: "%d%T%p%T%t%m%n"
      appender：
        — type: (StdoutLogAppender, FileLogAppender)
          level: (debug, ...)
          file: logs/xxx.log

使用日志一般是这样：
现在全局范围内定义一个logger： sylar::Logger g_logger = syaler::LoggerMgr->getInstance()->getLogger(name);
然后后面在使用的时候就直接用logger： SYLAR_LOG_INFO(g_logger) << "xxx log";
这样写的好处是找日志的时候是比较静态的，第一次在全局拿到logger之后支持继续往下去改.
那我们要支持这种功能应该怎么做呢？如果我这个日志没定义logger，那肯定是找不到的，没定义返回的就是root，当我定义好logger之后，怎么保证我后面继续写日志的时候，
他能正常的写到我定义的日志上去呢？所以要解决这个问题。
通过全局静态的Logger::ptr对象来使得日志分层

注：logger和level类的设计还有提升空间，要遵从解耦和单一功能原则(网友弹幕)

logger的信息反序列化成yml输出存在的问题.png记载的是，上面是logger中的信息反序列化成yml输出，下面是原始的yml，存在的问题是：
原始的yml中，appenders下并没有设置formatter，但是反序列化后却输出了，这是因为输出的是更上一层(父节点)的formatter，我们不想让它输出其父节点的，有就输出，没有就不输出。
解决方案是：appender得知道自己有没有formatter

## 线程库
Thread Mutex
做一个轻量级的线程，线程作为协程的一个容器
我们更多的是用协程在做高并发的

c++11之前都是用pthread_xxx
c++11之后都是用自带的std::thread，但是其还是用pthread来实现的
问：c++11之前和之后，线程的使用方式有什么不同？

本项目用pthread来创建线程、实现信号量和互斥量
为什么不用c++11的线程来做呢？因为c+11线程里的互斥量没有读写分离的方式，而往往在大并发的情况下，读写分离会使得性能提高很多

在信号量里，注意的是在出线程构造函数之前，他要启动的线程就一定启动了，这样就保证了线程类生成之前，线程就已经跑起来了

思考一下如何测试多线程使用日志时，自己写的thread模块是符合预期的？是线程安全的？
做实验复现出多线程日志打印串行的情况

加锁或不加锁，日志输出速度差了很多倍，需要优化这个性能(怎么测试出差了十几倍的？答：肉眼看的，看每秒写入文件的大小，加Mutex锁大约每秒写入10M，改为spinlock后，每秒写入大概20M，提升了2倍左右，但比起不加锁，每秒写入100M还是差了很多)
优化措施：将Mutex换成轻量级的spinlock，spinlock性能会好一点，它如果没获得到锁的话，它不会马上陷入内核态，只会在cpu上空跑，
这样cpu消耗可能会高一点，但是等待锁的时间会少很多，往往针对冲突比较多，冲突时间比较短的情况下，会有提升
测试一下，一个线程不加锁全力写日志，好像也就是每秒20M左右？

CAS机制？

存在一个问题，日志正在写到文件中时，如果删除文件，不会报错，也不会产生新的文件继续写？这是什么原因，我跟着up的方法有bug，所以这是个遗留问题，思考如何解决？

配置模块都是写少读多，所以用读写锁了

## 协程库封装
协程和异步
异步：对开发人员技术功底很高。如果出现很多层次的异步调用，会比较混乱，调试很难，开发很难。
协程：可以将异步的操作封装成同步。用一个协程库+底层kuke，kuke到socket API那一层，当API要请求异步操作的时候，把读写事件先注册起来，然后当请求读写的时候，会陷入到epoll里面去，此时把整个协程先挂起来，当数据回来的时候，再从协程把它唤起。这样写程序的人，并不需要知道协程库的存在，只需要用我们这套协程库框架，自然而然的像写同步一样，写的代码是同步的，但能实现异步的功能。

## socket函数库开发

## HTTP协议开发

## 分布式协议
在高性能服务器开发中，分布式服务器内部都有共享请求，内部共享请求走HTTP协议，性能可能会比较差一点，没有二进制方便，因此要有一个分布式协议。
把要做的逻辑业务抽象成一个个插件，以SO的形式来提供。
服务器在跑起来的时候，自然而然能实现服务器之间的交互，交互的逻辑放在插件中，这样就把业务功能和系统功能拆分开来了。业务开发归业务开发，系统优化归系统优化。

## 推荐系统